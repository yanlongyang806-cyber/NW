Light

// Inputs: position_vs.xyz, N_vs (no mapping, assume these names from an Output.phl equivalent)
// Mapped per-light inputs: See GfxMaterialProfile.c

NormalText <<
						{
							float3 shadow_color=0, light_type_minus_one=2;
#ifndef NO_CCLIGHTING
							shadow_color = %light.shadow_color%;
							light_type_minus_one = %light.light_type%;
#endif

						// spot_light.Light
						lightSpot(diffuseComponent, diffuseLightingValue, specularComponent, shadow_term, 
							spec_exponent, light_bleed, N_vs, reflect_vs, view_vs, bitangent,
							%light.dir_vs%, %light.pos_vs%, position_vs, 
							%light.one_plus_inner_radius_over_dradius%, %light.neg_inv_dradius%,
							%light.neg_cos_outer_angle_over_d_cos_angle%, %light.inv_d_cos_angle%,
							%light.diffuse%, %light.ambient% * ambient_occlusion, %light.specular%, %light.shadow_mask%,
							shadow_color,
							light_type_minus_one.x
							DIFFUSE_WARP_SAMPLER_CALL()
							);
						}
#ifdef ShowNumLightsPerObject
	#define DEBUG_OUT
	debug_out += 0.2;
#endif
>>

ShadowTestText <<
							// spot_light.Light
							{
#ifdef SCATTERING
								shadow_term = 0;


								float delta_len = length(position_vs);
								float scattering = 0.0f;
								
								#ifdef _PS3
								#ifndef TRANSGAMING
								[flatten]
								#endif
								#endif
								float far_limit = 60;
								if (delta_len > far_limit)
								{
									// bring initial sample position start pos in to the outer shadowmap
									position_vs *= far_limit / delta_len;

									delta_len = far_limit;
								}

						
								const int SAMPLES = 128;

								float3 position_delta, light_to_pos;
								float decay_per_step = exp( scatter_param.y * delta_len );
								float scatter_per_step = scatter_param.z * ( 1 - decay_per_step );
								float4 shadow_coord;


								light_to_pos = position_vs - %light.pos_vs%;
								position_delta = position_vs * (-1.0 / (SAMPLES+1));
								delta_len = length(position_delta);



								decay_per_step = exp( scatter_param.y * delta_len );
								scatter_per_step = scatter_param.z * ( 1 - decay_per_step );
								#ifndef _PS3
								#ifndef TRANSGAMING
								[unroll(SAMPLES)]
								#endif
								#endif
								for (int sample1 = 0; sample1 < SAMPLES; ++sample1)
								{
									shadow_coord.x = dot(%shadowmap0.camera_to_shadowmap_x%, float4(position_vs, 1));
									shadow_coord.y = dot(%shadowmap0.camera_to_shadowmap_y%, float4(position_vs, 1));
									shadow_coord.z = dot(%shadowmap0.camera_to_shadowmap_z%, float4(position_vs, 1));
									shadow_coord.w = dot(%shadowmap0.camera_to_shadowmap_w%, float4(position_vs, 1));
									
									float2 sm_shadow_coord = shadow_coord.xy / shadow_coord.w;
									// clip to first quadrant
									if ( sm_shadow_coord.x > 0.0 && sm_shadow_coord.x < 0.5 && 
										sm_shadow_coord.y > 0.0 && sm_shadow_coord.y < 0.5 )
									{
										float bScatterThisStep = shadowLookupSingle(%shadowmap.texture%, sam%shadowmap.texture%, shadow_coord, %shadowmap.texture_size%);

										float lightdir_length = length(light_to_pos);
										// distance falloff
										bScatterThisStep *= mad_sat1(lightdir_length, %light.neg_inv_dradius%, %light.one_plus_inner_radius_over_dradius%);
										// angular falloff
										bScatterThisStep *= mad_sat1(dot(%light.dir_vs%, light_to_pos)/lightdir_length, %light.inv_d_cos_angle%, %light.neg_cos_outer_angle_over_d_cos_angle%);
										
										scattering += bScatterThisStep * scatter_per_step;
									}
									scattering *= decay_per_step;

									position_vs += position_delta;
									light_to_pos += position_delta;
								}
							
								shadow_term = %light.shadow_mask% * sqrt( scattering * scatter_param.w );

#else
								float shadow_value;
								float4 shadow_coord;
								shadow_coord.x = dot(%shadowmap0.camera_to_shadowmap_x%, float4(position_vs, 1));
								shadow_coord.y = dot(%shadowmap0.camera_to_shadowmap_y%, float4(position_vs, 1));
								shadow_coord.z = dot(%shadowmap0.camera_to_shadowmap_z%, float4(position_vs, 1));
								shadow_coord.w = dot(%shadowmap0.camera_to_shadowmap_w%, float4(position_vs, 1));
								shadow_value = shadowLookup(%shadowmap.texture%, sam%shadowmap.texture%, shadow_coord, %shadowmap.texture_size%, 3);
								shadow_term = %light.shadow_mask% * clamp(1 - shadow_value, %light.max_shadow_val%, %light.min_shadow_val%);
#endif
							}
>>

// these line up with doVertexLighting in vs_inc.hlsl
VertexLightParams
{
	Param light.diffuse, light.inv_d_cos_angle
	Param light.pos_vs, light.one_plus_inner_radius_over_dradius
	Param light.ambient, light.neg_inv_dradius
	Param light.dir_vs, light.neg_cos_outer_angle_over_d_cos_angle
}

SingleDirLightParams
{
	Param light.dir_vs
	Param light.diffuse
	Param light.secondary_diffuse
	Param light.specular
}

EndLight
